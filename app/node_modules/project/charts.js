var c3 = require('c3');
var dom = require('dom-events');
var moment = require('moment');

var colorIndex = 0;
var palate = ['#4A90E2', '#FFC700', '#FF5C00'];

function nextColor() {
  return palate[colorIndex++] || palate[colorIndex = 0, colorIndex++]
}
function formatDate(d) {
  return parseInt(new Date(d).getMonth())+1 + '/' + parseInt(new Date(d).getDate()) + '/' + new Date(d).getFullYear();
}
function formatId(id) {
  return id.replace(/\//g,'-').replace(/ /g, '-').replace('-Open', '').replace('-Closed', '');
}

var loaded

function calculate(data, filters) { 

  var calculated = {
    columns: [],
    colors: {
      'Unassigned Open': d3.rgb('#aaa'),
      'Unassigned Closed': d3.rgb('#aaa').darker(2)
    }
  };

  var totals = { 'Unassigned Open': 0, 'Unassigned Closed': 0 };
  var completion = 0;
  var issuecount = 0;
  var projectcount = Object.keys(data).length;
  var dates = {
    today: new Date().getTime(),
    earliest: new Date().getTime(),
    latest: new Date().getTime(),
    milestones: []
  };

  for (var repo in data) {

    var urlparts = repo.split('/');
    var reponame = urlparts.pop();
    var username = urlparts.pop();
    var issues = data[repo].issues;
    var milestones = data[repo].milestones;

    if (filters && filters.length && filters.indexOf(repo) == -1) {
      continue;
    }

    for (var i = 0; i < issues.length; i++) {
      if (issues[i].milestone == null) { 
        ++totals[issues[i].state == 'open' 
          ? 'Unassigned Open' 
          : 'Unassigned Closed'];
      }
      var issue_opened = new Date(issues[i].created_at).getTime()
      if (issue_opened < dates.earliest) {
        dates.earliest = issue_opened;
      }
    }

    for (var i = 0; i < milestones.length; i++) {

      var m = milestones[i];
      var prefix = username + '/' + reponame + '/' + m.title;
      var open = prefix + ' Open';
      var closed = prefix + ' Closed';

      if (m.due_on) {
        var due = new Date(m.due_on).getTime();
        if (due > dates.latest) {
          dates.latest = due;
        }
        dates.milestones.push([m.title, due, prefix])        
      }

      totals[open] = totals[open] || 0;
      totals[closed] = totals[closed] || 0;

      totals[open] += m.open_issues;
      totals[closed] += m.closed_issues;

      var color = nextColor();

      issuecount += m.open_issues + m.closed_issues;
      completion += m.closed_issues;

      calculated.colors[open] = d3.rgb(color);
      calculated.colors[closed] = d3.rgb(color).darker(1);
    }

  }

  for (var label in totals) {
    calculated.columns.push([label, (totals[label] / 100) * (projectcount * 100) ]);
  }

  calculated.dates = dates;
  calculated.complete = (parseInt((completion * 100) / issuecount) || 0) + '%';
  return calculated;
};

var milestonesChart;

exports.milestones = function(data, filters) {

  if (!milestonesChart) {
    milestonesChart = c3.generate({
      bindto: '#milestonesChart',
      data: {
        columns: [
        ],
        type : 'donut',
        onmouseover: function(d) {
          var id = d.id;
          var tid = 'tip-' + formatId(id);
          d3.select('#' + tid).classed({hidden: false})
          d3.select('#tip-today').classed({hidden: true});
        },
        onmouseout: function(d) {
          var id = d.id;
          var tid = 'tip-' + formatId(id);
          d3.select('#' + tid).classed({hidden: true})
          d3.select('#tip-today').classed({hidden: false});
        }
      },
      donut: {
        title: ''
      },
      legend: {
        position: 'right',
        item: {
          onmouseover: function(id) {
            var tid = 'tip-' + formatId(id);
            var el = d3.select('#' + tid).classed({hidden: false})
            d3.select('#tip-today').classed({hidden: true});
          },
          onmouseout: function(id) {
            var tid = 'tip-' + formatId(id);
            d3.select('#' + tid).classed({hidden: true})
            d3.select('#tip-today').classed({hidden: false});
          }
        }
      },
      tooltip: {
        show: false
      }
    });
  }
  else {
    milestonesChart.unload();
  }

  var calculated = calculate(data, filters);

  milestonesChart.data.colors(calculated.colors);
  
  setTimeout(function() {
    milestonesChart.load({
      columns: calculated.columns
    });

    var completionEl = document.querySelector('.c3-chart-arcs-title');
    completionEl.textContent = calculated.complete;
  
  }, 1000);

};


exports.datebar = function(data, filters) {

  var calculated = calculate(data, filters);
  var datebar = document.querySelector('.datebar');
  datebar.style.disply = 'block';
  var progress = datebar.querySelector('.progress');

  var dates_width = datebar.offsetWidth;
  var inbetween = (calculated.dates.latest / 1000) - (calculated.dates.earliest / 1000);
  var per_pixel = Math.floor(inbetween / dates_width);

  d3.selectAll('.datebar-tooltip').each(function() { this.remove() });

  function createTip(text, id, classes, date, hidden) {
    var offset = Math.floor(((date / 1000) - (calculated.dates.earliest / 1000)) / per_pixel);

    var tip = document.createElement('div')
    tip.className = classes || 'tooltip datebar-tooltip'
    tip.id = 'tip-' + id;
    tip.style.left = offset + 'px';
    tip.appendChild(document.createTextNode(text));

    progress.appendChild(tip);
    
    var left = Math.floor(offset - (tip.offsetWidth / 2));
    d3.select('#' + tip.id).style('left', left+'px').classed({hidden: hidden});
  }

  calculated.dates.milestones.forEach(function(m) {
    var title = m[0] + ' ' + formatDate(m[1]);
    var id = m[2].replace(/\//g,'-').replace(/ /g, '-');
    createTip(title, id, 'tooltip datebar-tooltip', m[1], true);
  });

  createTip('Today', 'today', 'tooltip datebar-tooltip', calculated.dates.today)
  createTip(
    'Start ' + formatDate(calculated.dates.earliest),
    'start', 'tooltip-bottom tooltip-start datebar-tooltip', calculated.dates.earliest);
  createTip(
    'End ' + formatDate(calculated.dates.latest),
    'end', 'tooltip-bottom tooltip-end datebar-tooltip', calculated.dates.latest);

  
  progress.style.width = calculated.complete;

};

var contributionsChart;

exports.contributions = function(data, filters) { 

  if (!contributionsChart) {
    contributionsChart = c3.generate({
      bindto: '#contributionsChart',
      data: {
        x: 'x',
        columns: [
          ['x']
        ],
        type : 'area-spline'
      },
      axis: {
        x: {
          type: 'timeseries',
          tick: {
            format: function (x) { return moment.unix(x).format('DD-MMM-YY') }
          }
        }
      },
      legend: {
        show: false
      },
      point: {
        show: false
      }
    });
  }
  else {
    contributionsChart.unload();
  }

  var template = require('./templates/contributors.jade');
  var contributorsDiv = document.querySelector('.contributors');  

  contributorsDiv.innerHTML = '';
  var contributors = {};
  var columns = [];
  var chartData = {
    x: 'x',
    columns: [
      []
    ]
  };
 
  var total = 0;
  var len; 

  for (var repo in data) {

    if (filters && filters.length && filters.indexOf(repo) == -1) {
      continue;
    }

    var contribs = data[repo].contributors;

    for (var i = 0; i < contribs.length; i++) {
      var contributor = contribs[i];
      var weeks = contributor.weeks;
      for (var j = 0; j < weeks.length; j++) {
        var week = weeks[j];
        if (chartData.columns[0].indexOf(week.w) == -1) {
          chartData.columns[0].push(week.w);
        }
      }
    }

    len = chartData.columns[0].length;
  }

  if (!len) return;

  var columnData = new Array(len+1).join('0').split('').map(parseFloat);

  for (var repo in data) {

    if (filters && filters.length && filters.indexOf(repo) == -1) {
      continue;
    }
 
    var contribs = data[repo].contributors;

    for (var i = 0; i < contribs.length; i++) {

      var contributor = contribs[i];
      var weeks = contributor.weeks;
      var login = contributor.author.login;
      var index = len;

      for(var j = weeks.length-1; j >= 0; j--) {
        var week = weeks[j];
        columnData[index--] += week.a + week.c + week.d;
      }

      if (contributors[login]) {
        contributors[login].total += contributor.total;
      }
      else {
        contributors[login] = contributor.author;
        contributors[login].total = contributor.total;
      }
      total += contributor.total;
    }
  }

  columnData[0] = 'contributions';
  chartData.columns.push(columnData);

  for (var c in contributors) {
    contributors[c].percentage = 
      (contributors[c].total * 100 / total).toFixed(2) + '%';
  }
  
  contributorsDiv.innerHTML = template({ data: contributors });
  chartData.columns[0] = chartData.columns[0].sort();
  chartData.columns[0].unshift('x');

  setTimeout(function() {

    // what the fuck is this all about?
    // it seems the chart wont render if
    // its not visible, maybe it depends 
    // on the dom for the math that it's doing.
    // which is fucking lame. fuck you.

    contributionsChart.load(chartData);
  }, 1000);

};

